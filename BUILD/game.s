;
; File generated by cc65 v 2.19 - Git 911ff40
;
	.fopt		compiler,"cc65 v 2.19 - Git 911ff40"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_col
	.import		_pal_bright
	.import		_ppu_wait_nmi
	.import		_ppu_wait_frame
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_meta_spr
	.import		_music_play
	.import		_pad_poll
	.import		_pad_trigger
	.import		_bank_spr
	.import		_set_vram_update
	.import		_vram_adr
	.import		_vram_put
	.import		_vram_unrle
	.import		_memcpy
	.import		_set_vram_buffer
	.import		_set_music_speed
	.import		_check_collision
	.export		_beep
	.export		_pad1
	.export		_pad1_new
	.export		_collision1
	.export		_collision2
	.export		_collision3
	.export		_collision4
	.export		_collision5
	.export		_coin_collision
	.export		_i
	.export		_numEnemies
	.export		_collision_L
	.export		_collision_R
	.export		_collision_U
	.export		_collision_D
	.export		_playerDead
	.export		_which_bg
	.export		_p_maps
	.export		_coordinates
	.export		_temp1
	.export		_temp2
	.export		_temp3
	.export		_temp4
	.export		_temp_x
	.export		_temp_y
	.export		_song
	.export		_c_map
	.export		_boop
	.export		_All_Collision_Maps
	.export		_sprPlayer
	.export		_sprGhost
	.export		_sprCoin
	.export		_draw_bg
	.export		_draw_sprites
	.export		_movement
	.export		_bg_collision
	.export		_coin_pickup
	.export		_GoodGuy1
	.export		_BadGuy1
	.export		_BadGuy2
	.export		_BadGuy3
	.export		_BadGuy4
	.export		_BadGuy5
	.export		_BadGuy6
	.export		_coin
	.export		_collided
	.export		_enemyList
	.export		_enemy_dx
	.export		_enemy_dy
	.export		_palTitle
	.export		_show_title
	.export		_fade_out
	.export		_fade_in
	.export		_test_collision
	.export		_main

.segment	"DATA"

_numEnemies:
	.byte	$01
_playerDead:
	.byte	$00
_GoodGuy1:
	.byte	$80
	.byte	$40
	.byte	$0F
	.byte	$0F
_BadGuy1:
	.byte	$80
	.byte	$A8
	.byte	$0F
	.byte	$0F
_BadGuy2:
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
_BadGuy3:
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
_BadGuy4:
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
_BadGuy5:
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
_BadGuy6:
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
_coin:
	.byte	$64
	.byte	$64
	.byte	$07
	.byte	$07
_collided:
	.word	$0000
_enemyList:
	.byte	$80
	.byte	$A8
	.byte	$0F
	.byte	$0F
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F
	.byte	$78
	.byte	$78
	.byte	$0F
	.byte	$0F

.segment	"RODATA"

_beep:
	.byte	$02
	.byte	$00
	.byte	$02
	.byte	$81
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$00
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$00
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$04
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$00
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$00
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$06
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$07
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$07
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$00
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$00
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$07
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$07
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$00
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$40
	.byte	$41
	.byte	$00
	.byte	$02
	.byte	$08
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$00
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$42
	.byte	$43
	.byte	$00
	.byte	$02
	.byte	$FE
	.byte	$00
	.byte	$02
	.byte	$2D
	.byte	$30
	.byte	$32
	.byte	$25
	.byte	$33
	.byte	$33
	.byte	$00
	.byte	$00
	.byte	$33
	.byte	$34
	.byte	$21
	.byte	$32
	.byte	$34
	.byte	$00
	.byte	$02
	.byte	$D3
	.byte	$04
	.byte	$15
	.byte	$00
	.byte	$44
	.byte	$15
	.byte	$C1
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$11
	.byte	$00
	.byte	$04
	.byte	$45
	.byte	$DD
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$01
	.byte	$00
	.byte	$04
	.byte	$05
	.byte	$0D
	.byte	$00
	.byte	$02
	.byte	$0B
	.byte	$A0
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$02
	.byte	$11
	.byte	$00
	.byte	$02
	.byte	$00
_boop:
	.byte	$08
	.byte	$08
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_All_Collision_Maps:
	.addr	_boop
_sprPlayer:
	.byte	$00
	.byte	$FF
	.byte	$49
	.byte	$00
	.byte	$08
	.byte	$FF
	.byte	$4A
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$4B
	.byte	$00
	.byte	$08
	.byte	$07
	.byte	$4C
	.byte	$00
	.byte	$80
_sprGhost:
	.byte	$00
	.byte	$FF
	.byte	$4D
	.byte	$00
	.byte	$08
	.byte	$FF
	.byte	$4E
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$4F
	.byte	$00
	.byte	$08
	.byte	$07
	.byte	$50
	.byte	$00
	.byte	$80
_sprCoin:
	.byte	$00
	.byte	$FF
	.byte	$45
	.byte	$00
	.byte	$08
	.byte	$FF
	.byte	$46
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$47
	.byte	$00
	.byte	$08
	.byte	$07
	.byte	$48
	.byte	$00
	.byte	$80
_palTitle:
	.byte	$0F
	.byte	$03
	.byte	$15
	.byte	$30
	.byte	$0F
	.byte	$01
	.byte	$21
	.byte	$31
	.byte	$0F
	.byte	$06
	.byte	$30
	.byte	$26
	.byte	$0F
	.byte	$09
	.byte	$19
	.byte	$29

.segment	"BSS"

_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_collision1:
	.res	1,$00
_collision2:
	.res	1,$00
_collision3:
	.res	1,$00
_collision4:
	.res	1,$00
_collision5:
	.res	1,$00
_coin_collision:
	.res	1,$00
_i:
	.res	1,$00
_collision_L:
	.res	1,$00
_collision_R:
	.res	1,$00
_collision_U:
	.res	1,$00
_collision_D:
	.res	1,$00
_which_bg:
	.res	1,$00
_p_maps:
	.res	2,$00
_coordinates:
	.res	1,$00
_temp1:
	.res	1,$00
_temp2:
	.res	1,$00
_temp3:
	.res	1,$00
_temp4:
	.res	1,$00
_temp_x:
	.res	1,$00
_temp_y:
	.res	1,$00
_song:
	.res	1,$00
_c_map:
	.res	240,$00
_enemy_dx:
	.res	10,$00
_enemy_dy:
	.res	10,$00
_wait:
	.res	1,$00
_frame_cnt:
	.res	1,$00
_iy:
	.res	2,$00
_dy:
	.res	2,$00
_Goodguy_dx:
	.res	2,$00
_Goodguy_dy:
	.res	2,$00

; ---------------------------------------------------------------
; void __near__ draw_bg (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_bg: near

.segment	"CODE"

;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; p_maps = All_Collision_Maps[which_bg];
;
	ldx     #$00
	lda     _which_bg
	asl     a
	bcc     L0019
	inx
	clc
L0019:	adc     #<(_All_Collision_Maps)
	sta     ptr1
	txa
	adc     #>(_All_Collision_Maps)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _p_maps+1
	dey
	lda     (ptr1),y
	sta     _p_maps
;
; memcpy (c_map, p_maps, 240);
;
	lda     #<(_c_map)
	ldx     #>(_c_map)
	jsr     pushax
	lda     _p_maps
	ldx     _p_maps+1
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; for(temp_y = 0; temp_y < 15; ++temp_y){
;
	lda     #$00
	sta     _temp_y
L001A:	lda     _temp_y
	cmp     #$0F
	bcs     L0003
;
; for(temp_x = 0; temp_x < 16; ++temp_x){
;
	lda     #$00
	sta     _temp_x
L001B:	lda     _temp_x
	cmp     #$10
	bcs     L001E
;
; temp1 = (temp_y << 4) + temp_x;
;
	lda     _temp_y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp_x
	sta     _temp1
;
; if(c_map[temp1]){
;
	ldy     _temp1
	lda     _c_map,y
	beq     L001D
;
; vram_put(0x10); // wall
;
	lda     #$10
	jsr     _vram_put
;
; vram_put(0x10);
;
	lda     #$10
;
; else{
;
	jmp     L0017
;
; vram_put(0); // blank
;
L001D:	jsr     _vram_put
;
; vram_put(0);
;
	lda     #$00
L0017:	jsr     _vram_put
;
; for(temp_x = 0; temp_x < 16; ++temp_x){
;
	inc     _temp_x
	jmp     L001B
;
; for(temp_x = 0; temp_x < 16; ++temp_x){
;
L001E:	lda     #$00
	sta     _temp_x
L001F:	lda     _temp_x
	cmp     #$10
	bcs     L0022
;
; temp1 = (temp_y << 4) + temp_x;
;
	lda     _temp_y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp_x
	sta     _temp1
;
; if(c_map[temp1]){
;
	ldy     _temp1
	lda     _c_map,y
	beq     L0021
;
; vram_put(0x10); // wall
;
	lda     #$10
	jsr     _vram_put
;
; vram_put(0x10);
;
	lda     #$10
;
; else{
;
	jmp     L0018
;
; vram_put(0); // blank
;
L0021:	jsr     _vram_put
;
; vram_put(0);
;
	lda     #$00
L0018:	jsr     _vram_put
;
; for(temp_x = 0; temp_x < 16; ++temp_x){
;
	inc     _temp_x
	jmp     L001F
;
; for(temp_y = 0; temp_y < 15; ++temp_y){
;
L0022:	inc     _temp_y
	jmp     L001A
;
; ppu_on_all(); // turn on screen
;
L0003:	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_meta_spr(GoodGuy1.x, GoodGuy1.y, sprPlayer);
;
	jsr     decsp2
	lda     _GoodGuy1
	ldy     #$01
	sta     (sp),y
	lda     _GoodGuy1+1
	dey
	sta     (sp),y
	lda     #<(_sprPlayer)
	ldx     #>(_sprPlayer)
	jsr     _oam_meta_spr
;
; oam_meta_spr(enemyList[0].x, enemyList[0].y, sprGhost);
;
	jsr     decsp2
	lda     _enemyList
	ldy     #$01
	sta     (sp),y
	lda     _enemyList+1
	dey
	sta     (sp),y
	lda     #<(_sprGhost)
	ldx     #>(_sprGhost)
	jsr     _oam_meta_spr
;
; for(i = 1; i < numEnemies; i++) {
;
	lda     #$01
	sta     _i
L0006:	lda     _i
	cmp     _numEnemies
	bcs     L0003
;
; oam_meta_spr(enemyList[i].x, enemyList[i].y, sprGhost);
;
	jsr     decsp2
	ldx     #$00
	lda     _i
	jsr     aslax2
	sta     ptr1
	txa
	clc
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #<(_enemyList)
	lda     (ptr1),y
	ldy     #$01
	sta     (sp),y
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	lda     (ptr1),y
	dey
	sta     (sp),y
	lda     #<(_sprGhost)
	ldx     #>(_sprGhost)
	jsr     _oam_meta_spr
;
; for(i = 1; i < numEnemies; i++) {
;
	inc     _i
	jmp     L0006
;
; oam_meta_spr(coin.x, coin.y, sprCoin);
;
L0003:	jsr     decsp2
	lda     _coin
	ldy     #$01
	sta     (sp),y
	lda     _coin+1
	dey
	sta     (sp),y
	lda     #<(_sprCoin)
	ldx     #>(_sprCoin)
	jmp     _oam_meta_spr

.endproc

; ---------------------------------------------------------------
; void __near__ movement (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_movement: near

.segment	"CODE"

;
; if(pad1 & PAD_LEFT){
;
	lda     _pad1
	and     #$02
	beq     L0024
;
; GoodGuy1.x -= 1;
;
	dec     _GoodGuy1
;
; else if (pad1 & PAD_RIGHT){
;
	jmp     L0004
L0024:	lda     _pad1
	and     #$01
	beq     L0004
;
; GoodGuy1.x += 1;
;
	inc     _GoodGuy1
;
; bg_collision((char *)&GoodGuy1);
;
L0004:	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     _bg_collision
;
; if(collision_R) GoodGuy1.x -= 1;
;
	lda     _collision_R
	beq     L0005
	dec     _GoodGuy1
;
; if(collision_L) GoodGuy1.x += 1;
;
L0005:	lda     _collision_L
	beq     L0006
	inc     _GoodGuy1
;
; if(pad1 & PAD_UP){
;
L0006:	lda     _pad1
	and     #$08
	beq     L0025
;
; GoodGuy1.y -= 1;
;
	dec     _GoodGuy1+1
;
; else if (pad1 & PAD_DOWN){
;
	jmp     L0009
L0025:	lda     _pad1
	and     #$04
	beq     L0009
;
; GoodGuy1.y += 1;
;
	inc     _GoodGuy1+1
;
; bg_collision((char *)&GoodGuy1);
;
L0009:	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     _bg_collision
;
; if(collision_D) GoodGuy1.y -= 1;
;
	lda     _collision_D
	beq     L000A
	dec     _GoodGuy1+1
;
; if(collision_U) GoodGuy1.y += 1;
;
L000A:	lda     _collision_U
	beq     L0029
	inc     _GoodGuy1+1
;
; for(i = 0; i < numEnemies; i++) {
;
	lda     #$00
L0029:	sta     _i
	tax
L0026:	lda     _i
	cmp     _numEnemies
	jcs     L0027
;
; bg_collision((char *)&enemyList[i]);
;
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	tay
	txa
	adc     #>(_enemyList)
	tax
	tya
	jsr     _bg_collision
;
; if(collision_R) enemyList[i].x -= 1;
;
	lda     _collision_R
	beq     L0010
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; if(collision_L) enemyList[i].x += 1;
;
L0010:	lda     _collision_L
	beq     L0011
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	clc
	adc     #$01
	sta     (ptr1),y
;
; bg_collision((char *)&enemyList[i]);
;
L0011:	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	tay
	txa
	adc     #>(_enemyList)
	tax
	tya
	jsr     _bg_collision
;
; if(collision_D) enemyList[i].y -= 1;
;
	lda     _collision_D
	beq     L0012
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (ptr1),y
;
; if(collision_U) enemyList[i].y += 1;
;
L0012:	lda     _collision_U
	beq     L000E
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	clc
	adc     #$01
	sta     (ptr1),y
;
; for(i = 0; i < numEnemies; i++) {
;
L000E:	ldx     #$00
	inc     _i
	jmp     L0026
;
; Goodguy_dx = 0;//
;
L0027:	txa
	sta     _Goodguy_dx
	sta     _Goodguy_dx+1
;
; Goodguy_dy = 0;//
;
	sta     _Goodguy_dy
	sta     _Goodguy_dy+1
;
; GoodGuy1.x += Goodguy_dx;//
;
	lda     _Goodguy_dx
	clc
	adc     _GoodGuy1
	sta     _GoodGuy1
;
; GoodGuy1.y += Goodguy_dy;//
;
	lda     _Goodguy_dy
	clc
	adc     _GoodGuy1+1
	sta     _GoodGuy1+1
;
; enemy_dx[0] = (GoodGuy1.x - enemyList[0].x);
;
	lda     _GoodGuy1
	sec
	sbc     _enemyList
	sta     _enemy_dx
	txa
	sbc     #$00
	sta     _enemy_dx+1
;
; enemy_dy[0] = (GoodGuy1.y - enemyList[0].y);
;
	lda     _GoodGuy1+1
	sec
	sbc     _enemyList+1
	sta     _enemy_dy
	txa
	sbc     #$00
	sta     _enemy_dy+1
;
; enemyList[0].x += enemy_dx[0]/20;
;
	lda     _enemy_dx
	ldx     _enemy_dx+1
	jsr     pushax
	lda     #$14
	jsr     tosdiva0
	clc
	adc     _enemyList
	sta     _enemyList
;
; enemyList[0].y += enemy_dy[0]/20;
;
	lda     _enemy_dy
	ldx     _enemy_dy+1
	jsr     pushax
	lda     #$14
	jsr     tosdiva0
	clc
	adc     _enemyList+1
	sta     _enemyList+1
;
; for(i = 1; i < numEnemies; i++) {
;
	lda     #$01
	sta     _i
L0028:	lda     _i
	cmp     _numEnemies
	bcc     L002A
;
; } 
;
	rts
;
; enemy_dx[i] = (enemyList[i - 1].x - enemyList[i].x);
;
L002A:	ldx     #$00
	lda     _i
	asl     a
	bcc     L0020
	inx
	clc
L0020:	adc     #<(_enemy_dx)
	tay
	txa
	adc     #>(_enemy_dx)
	tax
	tya
	jsr     pushax
	ldx     #$00
	lda     _i
	sec
	sbc     #$01
	bcs     L0018
	dex
L0018:	jsr     aslax2
	sta     ptr1
	txa
	clc
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #<(_enemyList)
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     aslax2
	sta     ptr1
	txa
	clc
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #<(_enemyList)
	lda     (ptr1),y
	jsr     tossuba0
	ldy     #$00
	jsr     staxspidx
;
; enemy_dy[i] = (enemyList[i - 1].y - enemyList[i].y);
;
	ldx     #$00
	lda     _i
	asl     a
	bcc     L0021
	inx
	clc
L0021:	adc     #<(_enemy_dy)
	tay
	txa
	adc     #>(_enemy_dy)
	tax
	tya
	jsr     pushax
	ldx     #$00
	lda     _i
	sec
	sbc     #$01
	bcs     L0019
	dex
L0019:	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     tossuba0
	ldy     #$00
	jsr     staxspidx
;
; enemyList[i].x += enemy_dx[i]/20;
;
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	tay
	txa
	adc     #>(_enemyList)
	tax
	tya
	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	lda     _i
	asl     a
	bcc     L0022
	ldx     #$01
	clc
L0022:	adc     #<(_enemy_dx)
	sta     ptr1
	txa
	adc     #>(_enemy_dx)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	lda     #$14
	jsr     tosdiva0
	jsr     tosaddax
	ldy     #$00
	jsr     staspidx
;
; enemyList[i].y += enemy_dy[i]/20;
;
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	tay
	txa
	adc     #>(_enemyList)
	tax
	tya
	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	lda     _i
	asl     a
	bcc     L0023
	ldx     #$01
	clc
L0023:	adc     #<(_enemy_dy)
	sta     ptr1
	txa
	adc     #>(_enemy_dy)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	lda     #$14
	jsr     tosdiva0
	jsr     tosaddax
	ldy     #$01
	jsr     staspidx
;
; for(i = 1; i < numEnemies; i++) {
;
	inc     _i
	jmp     L0028

.endproc

; ---------------------------------------------------------------
; void __near__ bg_collision (char *object)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_bg_collision: near

.segment	"CODE"

;
; void bg_collision(char * object){
;
	jsr     pushax
;
; collision_L = 0;
;
	lda     #$00
	sta     _collision_L
;
; collision_R = 0;
;
	sta     _collision_R
;
; collision_U = 0;
;
	sta     _collision_U
;
; collision_D = 0;
;
	sta     _collision_D
;
; temp1 = object[0]; // left side
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	sta     _temp1
;
; temp2 = temp1 + object[2]; // right side
;
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$02
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	clc
	adc     _temp1
	sta     _temp2
;
; temp3 = object[1]; // top side
;
	dey
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	iny
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     _temp3
;
; temp4 = temp3 + object[3]; // bottom side
;
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$03
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	clc
	adc     _temp3
	sta     _temp4
;
; if(temp3 >= 0xf0) return;
;
	lda     _temp3
	cmp     #$F0
	jcs     L000D
;
; coordinates = (temp1 >> 4) + (temp3 & 0xf0); // upper left
;
	lda     _temp1
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _temp3
	and     #$F0
	clc
	adc     ptr1
	sta     _coordinates
;
; if(c_map[coordinates]){ // find a corner in the collision map
;
	ldy     _coordinates
	lda     _c_map,y
	beq     L0015
;
; ++collision_L;
;
	inc     _collision_L
;
; ++collision_U;
;
	inc     _collision_U
;
; coordinates = (temp2 >> 4) + (temp3 & 0xf0); // upper right
;
L0015:	lda     _temp2
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _temp3
	and     #$F0
	clc
	adc     ptr1
	sta     _coordinates
;
; if(c_map[coordinates]){
;
	ldy     _coordinates
	lda     _c_map,y
	beq     L0016
;
; ++collision_R;
;
	inc     _collision_R
;
; ++collision_U;
;
	inc     _collision_U
;
; if(temp4 >= 0xf0) return;
;
L0016:	lda     _temp4
	cmp     #$F0
	bcs     L000D
;
; coordinates = (temp1 >> 4) + (temp4 & 0xf0); // bottom left
;
	lda     _temp1
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _temp4
	and     #$F0
	clc
	adc     ptr1
	sta     _coordinates
;
; if(c_map[coordinates]){
;
	ldy     _coordinates
	lda     _c_map,y
	beq     L0017
;
; ++collision_L;
;
	inc     _collision_L
;
; ++collision_D;
;
	inc     _collision_D
;
; coordinates = (temp2 >> 4) + (temp4 & 0xf0); // bottom right
;
L0017:	lda     _temp2
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _temp4
	and     #$F0
	clc
	adc     ptr1
	sta     _coordinates
;
; if(c_map[coordinates]){
;
	ldy     _coordinates
	lda     _c_map,y
	beq     L000D
;
; ++collision_R;
;
	inc     _collision_R
;
; ++collision_D;
;
	inc     _collision_D
;
; }
;
L000D:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ coin_pickup (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_coin_pickup: near

.segment	"CODE"

;
; coin_collision = check_collision(&GoodGuy1, &coin);
;
	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     pushax
	lda     #<(_coin)
	ldx     #>(_coin)
	jsr     _check_collision
	sta     _coin_collision
;
; if (coin_collision) {
;
	lda     _coin_collision
	beq     L0010
;
; if (GoodGuy1.x < 100) {
;
	lda     _GoodGuy1
	cmp     #$64
	bcs     L000D
;
; if (GoodGuy1.y < 100) {
;
	lda     _GoodGuy1+1
	cmp     #$64
	bcs     L000C
;
; coin.x = 50;
;
	lda     #$32
	sta     _coin
;
; coin.y = 175;
;
	lda     #$AF
;
; else {
;
	jmp     L000B
;
; coin.x = 200;
;
L000C:	lda     #$C8
	sta     _coin
;
; coin.y = 175;
;
	lda     #$AF
;
; else {
;
	jmp     L000B
;
; if (GoodGuy1.y < 100) {
;
L000D:	lda     _GoodGuy1+1
	cmp     #$64
	bcs     L000E
;
; coin.x = 50;
;
	lda     #$32
;
; else {
;
	jmp     L0011
;
; coin.x = 200;
;
L000E:	lda     #$C8
L0011:	sta     _coin
;
; coin.y = 40;
;
	lda     #$28
L000B:	sta     _coin+1
;
; if (numEnemies != maxEnemies) {
;
	lda     _numEnemies
	cmp     #$05
	beq     L000A
;
; numEnemies++;
;
	inc     _numEnemies
;
; } else {
;
	rts
;
; pal_col(0,0x0f);
;
L0010:	jsr     pusha
	lda     #$0F
	jmp     _pal_col
;
; }
;
L000A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ show_title (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_show_title: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(beep);
;
	lda     #<(_beep)
	ldx     #>(_beep)
	jsr     _vram_unrle
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; iy=220<<FP_BITS;
;
	ldx     #$0D
	lda     #$C0
	sta     _iy
	stx     _iy+1
;
; ppu_wait_frame();
;
L0002:	jsr     _ppu_wait_frame
;
; if (pad_trigger(0)&PAD_START) 
;
	lda     #$00
	jsr     _pad_trigger
	and     #$10
;
; {break;}
;
	bne     L0003
;
; iy+=dy;//
;
	lda     _dy
	clc
	adc     _iy
	sta     _iy
	lda     _dy+1
	adc     _iy+1
	sta     _iy+1
;
; if(iy<0)//
;
	ldx     _iy+1
	cpx     #$80
	bcc     L0006
;
; iy =0;//
;
	lda     #$00
	sta     _iy
	sta     _iy+1
;
; dy=-dy>>1;//
;
	lda     _dy
	ldx     _dy+1
	jsr     negax
	jsr     asrax1
	sta     _dy
	stx     _dy+1
;
; if(wait)//
;
L0006:	lda     _wait
	beq     L0007
;
; --wait;//
;
	dec     _wait
;
; else//
;
	jmp     L0002
;
; pal_col(10,(frame_cnt&32)?0x0f:0x20);//
;
L0007:	lda     #$0A
	jsr     pusha
	lda     _frame_cnt
	and     #$20
	beq     L000B
	lda     #$0F
	jmp     L000C
L000B:	lda     #$20
L000C:	jsr     _pal_col
;
; ++frame_cnt;//
;
	inc     _frame_cnt
;
; while(1) {
;
	jmp     L0002
;
; }
;
L0003:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ fade_out (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_out: near

.segment	"CODE"

;
; for ( vb =4; vb!=0; vb--) {
;
	jsr     decsp1
	lda     #$04
	ldy     #$00
L0006:	sta     (sp),y
	lda     (sp),y
	beq     L0008
;
; pal_bright(vb);
;
	jsr     _pal_bright
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; for ( vb =4; vb!=0; vb--) {
;
	ldy     #$00
	lda     (sp),y
	sec
	sbc     #$01
	jmp     L0006
;
; pal_bright(0);
;
L0008:	jsr     _pal_bright
;
; set_vram_update(NULL);
;
	ldx     #$00
	txa
	jsr     _set_vram_update
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ fade_in (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_in: near

.segment	"CODE"

;
; for(vb=0; vb<=4; vb++) {
;
	jsr     decsp1
	lda     #$00
	tay
L0006:	sta     (sp),y
	cmp     #$05
	bcs     L0003
;
; pal_bright(vb);
;
	lda     (sp),y
	jsr     _pal_bright
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; for(vb=0; vb<=4; vb++) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0006
;
; }
;
L0003:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ test_collision (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_test_collision: near

.segment	"CODE"

;
; collision1 = check_collision(&GoodGuy1, &enemyList[0]);
;
	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     pushax
	lda     #<(_enemyList)
	ldx     #>(_enemyList)
	jsr     _check_collision
	sta     _collision1
;
; collision2 = check_collision(&GoodGuy1, &enemyList[1]);
;
	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     pushax
	lda     #<(_enemyList+4)
	ldx     #>(_enemyList+4)
	jsr     _check_collision
	sta     _collision2
;
; collision3 = check_collision(&GoodGuy1, &enemyList[2]);
;
	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     pushax
	lda     #<(_enemyList+8)
	ldx     #>(_enemyList+8)
	jsr     _check_collision
	sta     _collision3
;
; collision4 = check_collision(&GoodGuy1, &enemyList[3]);
;
	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     pushax
	lda     #<(_enemyList+12)
	ldx     #>(_enemyList+12)
	jsr     _check_collision
	sta     _collision4
;
; collision5 = check_collision(&GoodGuy1, &enemyList[4]);
;
	lda     #<(_GoodGuy1)
	ldx     #>(_GoodGuy1)
	jsr     pushax
	lda     #<(_enemyList+16)
	ldx     #>(_enemyList+16)
	jsr     _check_collision
	sta     _collision5
;
; if (numEnemies == 1) {
;
	lda     _numEnemies
	cmp     #$01
	bne     L001F
;
; if (collision1) playerDead = 1;
;
	lda     _collision1
;
; else playerDead = 0;
;
	jmp     L002D
;
; } else if (numEnemies == 2) {
;
L001F:	lda     _numEnemies
	cmp     #$02
	bne     L0023
;
; if (collision1 || collision2) playerDead = 1;
;
	lda     _collision1
	bne     L002B
	lda     _collision2
;
; else playerDead = 0;
;
	jmp     L002D
;
; } else if (numEnemies == 3) {
;
L0023:	lda     _numEnemies
	cmp     #$03
	bne     L0027
;
; if (collision1 || collision2 || collision3) playerDead = 1;
;
	lda     _collision1
	bne     L002B
	lda     _collision2
	bne     L002B
	lda     _collision3
;
; else playerDead = 0;
;
	jmp     L002D
;
; } else if (numEnemies == 4) {
;
L0027:	lda     _numEnemies
	cmp     #$04
	bne     L0012
;
; if (collision1 || collision2 || collision3 || collision4) playerDead = 1;
;
	lda     _collision1
	bne     L002B
	lda     _collision2
	bne     L002B
	lda     _collision3
	bne     L002B
	lda     _collision4
;
; else playerDead = 0;
;
	jmp     L002D
;
; if (collision1 || collision2 || collision3 || collision4 || collision5) playerDead = 1;
;
L0012:	lda     _collision1
	bne     L002B
	lda     _collision2
	bne     L002B
	lda     _collision3
	bne     L002B
	lda     _collision4
	bne     L002B
	lda     _collision5
L002D:	beq     L001C
L002B:	lda     #$01
;
; else playerDead = 0;
;
L001C:	sta     _playerDead
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_off(); // screen off
;
L0002:	jsr     _ppu_off
;
; pal_bg(palTitle);
;
	lda     #<(_palTitle)
	ldx     #>(_palTitle)
	jsr     _pal_bg
;
; pal_spr(palTitle);
;
	lda     #<(_palTitle)
	ldx     #>(_palTitle)
	jsr     _pal_spr
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; song = 0;
;
	lda     #$00
	sta     _song
;
; music_play(song);
;
	jsr     _music_play
;
; ppu_on_all(); 
;
	jsr     _ppu_on_all
;
; fade_in();
;
	jsr     _fade_in
;
; show_title();
;
	jsr     _show_title
;
; fade_out();
;
	jsr     _fade_out
;
; draw_bg();
;
	jsr     _draw_bg
;
; fade_in();
;
	jsr     _fade_in
;
; music_play(song+1);
;
	lda     _song
	clc
	adc     #$01
	jsr     _music_play
;
; GoodGuy1.x = 128;
;
	lda     #$80
	sta     _GoodGuy1
;
; GoodGuy1.y = 64;
;
	lda     #$40
	sta     _GoodGuy1+1
;
; enemyList[0].x = 128;
;
	lda     #$80
	sta     _enemyList
;
; enemyList[0].y = 168;
;
	lda     #$A8
	sta     _enemyList+1
;
; for(i = 1; i < maxEnemies; i++) {
;
	lda     #$01
	sta     _i
L0015:	lda     _i
	cmp     #$05
	bcs     L0016
;
; enemyList[i].x = 120;
;
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	lda     #$78
	ldy     #$00
	sta     (ptr1),y
;
; enemyList[i].y = 120;
;
	ldx     #$00
	lda     _i
	jsr     aslax2
	clc
	adc     #<(_enemyList)
	sta     ptr1
	txa
	adc     #>(_enemyList)
	sta     ptr1+1
	lda     #$78
	iny
	sta     (ptr1),y
;
; for(i = 1; i < maxEnemies; i++) {
;
	inc     _i
	jmp     L0015
;
; coin.x = 100;
;
L0016:	lda     #$64
	sta     _coin
;
; coin.y = 100;
;
	sta     _coin+1
;
; for(i = 0; i < maxEnemies; i++) {
;
	lda     #$00
	sta     _i
L0017:	lda     _i
	cmp     #$05
	bcs     L0018
;
; enemy_dx[i] = 0;
;
	ldx     #$00
	lda     _i
	asl     a
	bcc     L0013
	inx
	clc
L0013:	adc     #<(_enemy_dx)
	sta     ptr1
	txa
	adc     #>(_enemy_dx)
	sta     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; enemy_dy[i] = 0;
;
	tax
	lda     _i
	asl     a
	bcc     L0014
	inx
	clc
L0014:	adc     #<(_enemy_dy)
	sta     ptr1
	txa
	adc     #>(_enemy_dy)
	sta     ptr1+1
	lda     #$00
	dey
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; for(i = 0; i < maxEnemies; i++) {
;
	inc     _i
	jmp     L0017
;
; ppu_wait_nmi(); // wait till beginning of the frame
;
L000E:	jsr     _ppu_wait_nmi
;
; set_music_speed(8);
;
	lda     #$08
	jsr     _set_music_speed
;
; oam_clear();
;
	jsr     _oam_clear
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; draw_sprites();
;
	jsr     _draw_sprites
;
; movement();
;
	jsr     _movement
;
; coin_pickup();
;
	jsr     _coin_pickup
;
; test_collision();
;
	jsr     _test_collision
;
; while (playerDead == 0){
;
L0018:	lda     _playerDead
	beq     L000E
;
; ppu_wait_frame();
;
	jsr     _ppu_wait_frame
;
; fade_out();
;
	jsr     _fade_out
;
; playerDead = 0;
;
	lda     #$00
	sta     _playerDead
;
; ppu_off();
;
	jsr     _ppu_off
;
; oam_clear();
;
	jsr     _oam_clear
;
; numEnemies = 1;
;
	lda     #$01
	sta     _numEnemies
;
; fade_out();
;
	jsr     _fade_out
;
; while(1) {
;
	jmp     L0002

.endproc

